syntax = "proto3";

package build.stack.bazel.registry.v1;

option go_package = "github.com/bazel-contrib/bcr-frontend/build/stack/bazel/registry/v1;bzpb";

import "build/stack/bazel/symbol/v1/symbol.proto";
import "build/stack/starlark/v1beta1/starlark.proto";

// Registry represents a Bazel module registry and all its modules.
message Registry {
    // List of modules in the registry
    repeated Module modules = 1;
    // Git repository URL (e.g., 'https://github.com/bazelbuild/bazel-central-registry')
    string repository_url = 2;
    // Public UI URL (e.g., 'https://registry.bazel.build')
    string registry_url = 3;
    // Git branch name (e.g., 'main')
    string branch = 4;
    // Git commit SHA-1 hash
    string commit_sha = 5;
    // Git commit message
    string commit_message = 6;
    // Git commit timestamp
    string commit_date = 7;
}

// Module represents a Bazel module and all its versions.
message Module {
    // Module name (e.g., 'rules_go', 'protobuf')
    string name = 1;
    // Module metadata from metadata.json
    ModuleMetadata metadata = 2;
    // List of versions, typically sorted newest to oldest
    repeated ModuleVersion versions = 3;
    // Optional repository metadata (GitHub, GitLab, etc.)
    RepositoryMetadata repository_metadata = 4;
}

// Maintainer represents a module maintainer from metadata.json.
message Maintainer {
    // Email address
    string email = 1;
    // Full name
    string name = 2;
    // GitHub username
    string github = 3;
    // Whether to skip notifications for this maintainer
    bool do_not_notify = 4;
    // GitHub user ID (numeric)
    int32 github_user_id = 5;
}

// ModuleMetadata represents a module's metadata.json file.
message ModuleMetadata {
    // Project homepage URL
    string homepage = 1;
    // List of module maintainers
    repeated Maintainer maintainers = 2;
    // Repository references (e.g., ['github:mateidavid/zstr'])
    repeated string repository = 3;
    // List of available versions
    repeated string versions = 4;
    // Map of yanked versions to their reasons
    map<string,string> yanked_versions = 5;
    // Deprecation message (empty if not deprecated)
    string deprecated = 6;
}

// RepositoryType indicates the source code hosting platform.
enum RepositoryType {
    REPOSITORY_TYPE_UNKNOWN = 0;
    GITHUB = 1;
    GITLAB = 2;
}

// RepositoryMetadata contains metadata about a module's source repository.
message RepositoryMetadata {
    // Repository type (GitHub, GitLab, etc.)
    RepositoryType type = 1;
    // Organization or user name
    string organization = 2;
    // Repository name
    string name = 3;
    // Repository description
    string description = 4;
    // Number of stars
    int32 stargazers = 5;
    // Map of programming languages to line counts
    map<string,int32> languages = 6;
    // Primary programming language
    string primary_language = 7;
    // Canonical name (org/repo)
    string canonical_name = 8;
}

// RepositoryMetadataSet is a collection of repository metadata.
message RepositoryMetadataSet {
    repeated RepositoryMetadata repository_metadata = 1;
}

// BazelRepositoryMetadata extends repository metadata with Bazel release information.
message BazelRepositoryMetadata {
    RepositoryMetadata repository_metadata = 1;
    repeated BazelRelease release = 2;
}

// BazelRelease represents a Bazel release version.
message BazelRelease {
    // Version tag (e.g., '7.0.0', '8.0.0-pre.20240101.1')
    string version = 1;
    // Source archive URL (.tar.gz)
    string url = 2;
    // Git commit details for the release
    ModuleCommit commit = 3;
}

// BazelReleaseSet is a collection of Bazel releases.
message BazelReleaseSet {
    repeated BazelRelease release = 1;
}

// ResourceStatus represents the HTTP status of a resource.
message ResourceStatus {
    // Resource URL
    string url = 1;
    // HTTP status code (e.g., 200, 404, 500)
    int32 code = 2;
    // HTTP status message
    string message = 3;
}

// ResourceStatusSet is a collection of resource statuses.
message ResourceStatusSet {
    repeated ResourceStatus status = 1;
}

// ModuleSource represents a source.json file for a module version.
message ModuleSource {
    // Source archive URL
    string url = 1;
    // Integrity hash (e.g., 'sha256-...')
    string integrity = 2;
    // Directory prefix to strip from the archive
    string strip_prefix = 3;
    // Number of leading path components to strip from patches
    int32 patch_strip = 4;
    // Map of patch filenames to their integrity hashes
    map<string, string> patches = 5;
    // Map of overlay filenames to their integrity hashes
    map<string, string> overlay = 6;
    // Optional URL to Stardoc documentation binary proto
    string docs_url = 7;
    // Mirror URLs for the source archive
    repeated string mirror_urls = 8;
    // Archive type (e.g., 'tar.gz', 'zip')
    string archive_type = 9;
    // Source type (e.g., 'git_repository', 'http_archive')
    string type = 10;
    // Git remote URL (for git_repository type)
    string remote = 11;
    // Git commit hash (for git_repository type)
    string commit = 12;
    // Optional Stardoc-derived documentation
    build.stack.bazel.symbol.v1.ModuleVersionSymbols documentation = 13;
    // HTTP status of docs_url
    ResourceStatus docs_url_status = 14;
    // HTTP status of source URL
    ResourceStatus url_status = 15;
    // Git commit SHA resolved from source URL (GitHub releases/tags)
    string commit_sha = 16;
}

// Attestations represents an attestations.json file for a module version.
message Attestations {
    // Attestation represents a single attestation entry.
    message Attestation {
        // URL to the attestation file
        string url = 1;
        // Integrity hash of the attestation
        string integrity = 2;
    }
    // Media type (e.g., 'application/vnd.dev.sigstore.bundle+json;version=0.1')
    string media_type = 1;
    // Map of filenames to their attestations
    map<string, Attestation> attestations = 2;
}

// A specific version of a Bazel module with dependencies and metadata
message ModuleVersion {
    // Module name
    string name = 1;
    // Semantic version (e.g., "1.2.3")
    string version = 2;
    // Compatibility level for this version
    int32 compatibility_level = 3;
    // Bazel versions compatible with this module version
    repeated string bazel_compatibility = 4;
    // Optional repository name override
    string repo_name = 5;
    // Direct dependencies of this module version
    repeated ModuleDependency deps = 6;
    // Source download information from source.json
    ModuleSource source = 7;
    // Cryptographic attestations from attestations.json
    Attestations attestations = 8;
    // Presubmit test configuration from presubmit.yml
    Presubmit presubmit = 9;
    // Toolchains to register when this module is loaded
    repeated string toolchains_to_register = 10;
    // Dependency overrides defined in this module version
    repeated ModuleDependencyOverride override = 11;
    // Git commit metadata for the MODULE.bazel file
    ModuleCommit commit = 12;
    // Repository metadata (denormalized from parent Module for UI convenience)
    RepositoryMetadata repository_metadata = 13;
    // Whether this is the latest version of the module
    bool is_latest_version = 14;
}

// Git commit metadata for a MODULE.bazel file submission
message ModuleCommit {
    // Commit SHA-1 hash
    string sha1 = 1;
    // Commit timestamp (ISO 8601 format)
    string date = 2;
    // Commit message text
    string message = 3;
    // Pull request number extracted from commit message
    string pull_request = 4;
}

// Override for a module dependency's source or version
message ModuleDependencyOverride {
    // Target module name for this override
    string module_name = 5;
    // Original MODULE.bazel code snippet
    string code = 6;
    oneof override {
        GitOverride git_override = 1;
        ArchiveOverride archive_override = 2;
        SingleVersionOverride single_version_override = 3;
        LocalPathOverride local_path_override = 4;
    }
}

// A dependency on another Bazel module
message ModuleDependency {
    // Dependency module name
    string name = 1;
    // Required version
    string version = 2;
    // Optional repository name override
    string repo_name = 3;
    // Whether this is a dev-only dependency
    bool dev = 4;
    // Maximum compatibility level accepted
    int32 max_compatibility_level = 5;
    // Override for this dependency's source or version
    ModuleDependencyOverride override = 6;
    // Whether version doesn't exist in registry (e.g., from pin_version)
    bool unresolved = 7;
}

// Override dependency with a specific Git commit
// Example: git_override(module_name = "foo", commit = "abc123", remote = "https://github.com/...")
message GitOverride {
    // Git commit SHA
    string commit = 1;
    // Number of leading path components to strip when applying patches
    int32 patch_strip = 2;
    // Patch files to apply to the source
    repeated string patches = 3;
    // Git repository URL
    string remote = 4;
    // Git branch name
    string branch = 5;
}

// Override dependency with an archive download
// Example: archive_override(module_name = "foo", urls = ["https://..."], integrity = "sha256-...")
message ArchiveOverride {
    // Subresource integrity hash (e.g., "sha256-...")
    string integrity = 1;
    // Number of leading path components to strip when applying patches
    int32 patch_strip = 2;
    // Patch files to apply to the extracted archive
    repeated string patches = 3;
    // Directory prefix to strip from extracted archive contents
    string strip_prefix = 4;
    // Download URLs for the archive
    repeated string urls = 5;
}

// Override dependency to use a specific version with optional patches
// Example: single_version_override(module_name = "foo", version = "1.2.3", patches = ["//patches:fix.patch"])
message SingleVersionOverride {
    // Number of leading path components to strip when applying patches
    int32 patch_strip = 1;
    // Patch files to apply to the version
    repeated string patches = 2;
    // Specific version to use
    string version = 3;
}

// Override dependency with a local filesystem path
// Example: local_path_override(module_name = "foo", path = "../local/foo")
message LocalPathOverride {
    // Path to the local module directory
    string path = 1;
}

// CI/CD testing configuration from presubmit.yml
message Presubmit {
    // Test module configuration for BCR presubmit checks
    message BcrTestModule {
        // Path to the module being tested
        string module_path = 1;
        // Platform and Bazel version matrix
        PresubmitMatrix matrix = 2;
        // Named tasks to execute
        map<string, PresubmitTask> tasks = 3;
    }

    // Test matrix for platforms and Bazel versions
    message PresubmitMatrix {
        // Platforms to test on (e.g., "ubuntu2004", "macos", "windows")
        repeated string platform = 1;
        // Bazel versions to test with (e.g., "7.x", "8.x", "rolling")
        repeated string bazel = 2;
    }

    // A single test task in the presubmit configuration
    message PresubmitTask {
        // Task name
        string name = 1;
        // Target platform (literal or template like "${{ platform }}")
        string platform = 2;
        // Bazel version (literal or template like "${{ bazel }}")
        string bazel = 3;
        // Additional flags for bazel build
        repeated string build_flags = 4;
        // Additional flags for bazel test
        repeated string test_flags = 5;
        // Targets to build
        repeated string build_targets = 6;
        // Targets to test
        repeated string test_targets = 7;
    }

    // Test module configuration (preferred format)
    BcrTestModule bcr_test_module = 1;
    // Top-level matrix (legacy format, used if bcr_test_module absent)
    PresubmitMatrix matrix = 2;
    // Top-level tasks (legacy format, used if bcr_test_module absent)
    map<string, PresubmitTask> tasks = 3;
}

// Node in a dependency tree resolved by Minimum Version Selection
message DependencyTreeNode {
    // Resolved module version
    ModuleVersion module_version = 1;
    // Originally requested version (may differ if MVS upgraded it)
    string requested_version = 2;
    // Whether MVS selected a higher version than requested
    bool upgraded = 3;
    // Whether this is a dev-only dependency
    bool dev = 4;
    // Transitive dependencies
    repeated DependencyTreeNode children = 5;
    // Whether children were pruned to avoid duplication
    bool pruned = 6;
    // Override type if applied: "single_version", "git", "archive", "local_path"
    string override_type = 7;
}

// Complete dependency tree for a module version after MVS resolution
message DependencyTree {
    // Root module version
    ModuleVersion module_version = 1;
    // Direct dependencies
    repeated DependencyTreeNode children = 2;
}
