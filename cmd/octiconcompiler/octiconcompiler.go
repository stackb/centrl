package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"maps"
	"os"
	"slices"
	"sort"
	"strings"

	"github.com/bazel-contrib/bcr-frontend/pkg/paramsfile"
)

const toolName = "octiconcompiler"

type ASTNode struct {
	Name       string            `json:"name"`
	Type       string            `json:"type"`
	Value      string            `json:"value"`
	Attributes map[string]string `json:"attributes"`
	Children   []ASTNode         `json:"children"`
}

type IconHeight struct {
	Width int     `json:"width"`
	Path  string  `json:"path"`
	AST   ASTNode `json:"ast"`
}

type Icon struct {
	Name     string                `json:"name"`
	Keywords []string              `json:"keywords"`
	Heights  map[string]IconHeight `json:"heights"`
}

type Config struct {
	OutputFile       string
	OcticonsJSONFile string
	Icons            map[string]Icon
}

func main() {
	log.SetPrefix(toolName + ": ")
	log.SetOutput(os.Stderr)
	log.SetFlags(0)

	if err := run(os.Args[1:]); err != nil {
		log.Fatal(err)
	}
}

func run(args []string) error {
	parsedArgs, err := paramsfile.ReadArgsParamsFile(args)
	if err != nil {
		return fmt.Errorf("failed to read params file: %v", err)
	}

	cfg, err := parseFlags(parsedArgs)
	if err != nil {
		return fmt.Errorf("failed to parse args: %v", err)
	}

	if cfg.OutputFile == "" {
		return fmt.Errorf("output_file is required")
	}
	if cfg.OcticonsJSONFile == "" {
		return fmt.Errorf("octicons_json is required")
	}

	// Parse octicons JSON
	data, err := os.ReadFile(cfg.OcticonsJSONFile)
	if err != nil {
		return fmt.Errorf("failed to read octicons.json: %v", err)
	}
	if err := json.Unmarshal(data, &cfg.Icons); err != nil {
		return fmt.Errorf("failed to parse octicons.json: %v", err)
	}

	// Transform AST: insert <g> element under each <svg>
	for name := range cfg.Icons {
		icon := cfg.Icons[name]
		for size := range icon.Heights {
			height := icon.Heights[size]
			height.AST = transformAST(height.AST)
			icon.Heights[size] = height
		}
		cfg.Icons[name] = icon
	}

	var out strings.Builder

	// Write file header
	fmt.Fprintf(&out, "/**\n")
	fmt.Fprintf(&out, " * Generated octicon SVG templates.\n")
	fmt.Fprintf(&out, " * DO NOT EDIT - generated by octiconcompiler\n")
	fmt.Fprintf(&out, " */\n")
	fmt.Fprintf(&out, "{namespace octicons}\n\n")

	// Sort icon names for deterministic output
	names := slices.Sorted(maps.Keys(cfg.Icons))

	// Generate a template for each icon and size combination
	for _, name := range names {
		icon := cfg.Icons[name]

		// Sort available sizes for consistent output
		sizes := getSortedSizes(icon.Heights)

		// Generate a template for each size
		for _, size := range sizes {
			height := icon.Heights[size]

			// Convert kebab-case to camelCase for template name
			// e.g., "package-16" -> "octiconPackage16"
			templateName := toCamelCase("octicon-" + name + "-" + size)

			fmt.Fprintf(&out, "/**\n")
			fmt.Fprintf(&out, " * Renders the %s octicon at %spx.\n", name, size)
			if len(icon.Keywords) > 0 {
				fmt.Fprintf(&out, " * Keywords: %s\n", strings.Join(icon.Keywords, ", "))
			}
			fmt.Fprintf(&out, " */\n")
			fmt.Fprintf(&out, "{template %s}\n", templateName)
			fmt.Fprintf(&out, "  {@param? class: string}\n")
			fmt.Fprintf(&out, "  {@param? style: string}\n")
			fmt.Fprintf(&out, "  {@param? fill: string}\n")
			fmt.Fprintf(&out, "  {@param? stroke: string}\n")
			fmt.Fprintf(&out, "  {@param? strokeWidth: string}\n")
			fmt.Fprintf(&out, "  {@param? ariaLabel: string}\n")

			// Render the AST recursively
			renderNode(&out, height.AST, "", true)

			fmt.Fprintf(&out, "{/template}\n\n")
		}
	}

	if err := os.WriteFile(cfg.OutputFile, []byte(out.String()), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %v", err)
	}

	log.Printf("Generated %d octicon templates to %s", len(cfg.Icons), cfg.OutputFile)
	return nil
}

// transformAST inserts a <g> element under each <svg> element and moves all
// svg children into the <g> element
func transformAST(node ASTNode) ASTNode {
	if node.Name == "svg" && node.Type == "element" {
		// Create a new <g> element with all the svg's children
		gNode := ASTNode{
			Name:       "g",
			Type:       "element",
			Value:      "",
			Attributes: make(map[string]string),
			Children:   node.Children,
		}

		// Return the svg with only the <g> as its child
		node.Children = []ASTNode{gNode}
		return node
	}

	// Recursively transform children
	for i, child := range node.Children {
		node.Children[i] = transformAST(child)
	}

	return node
}

// renderNode recursively renders an AST node as Soy template content
// isRoot indicates if this is the root svg element (to apply special handling for its g child)
func renderNode(out *strings.Builder, node ASTNode, indent string, isRoot bool) {
	if node.Type != "element" {
		return
	}

	// Opening tag
	fmt.Fprintf(out, "%s<%s", indent, node.Name)

	// Render attributes
	// Sort attribute names for deterministic output
	attrNames := slices.Sorted(maps.Keys(node.Attributes))

	for _, name := range attrNames {
		value := node.Attributes[name]
		fmt.Fprintf(out, " %s=\"%s\"", name, value)
	}

	// Special handling for <svg> element: add class and ariaLabel conditionals
	if node.Name == "svg" {
		fmt.Fprintf(out, "{if $class} class=\"octicon {$class}\"{else} class=\"octicon\"{/if}")
		fmt.Fprintf(out, "{if $style} style=\"{$style}\"{/if}")
		fmt.Fprintf(out, "{if $ariaLabel} aria-label=\"{$ariaLabel}\"{/if}")
	}

	// Special handling for <g> element (first child of svg): add fill/stroke conditionals
	if node.Name == "g" && isRoot {
		fmt.Fprintf(out, "{if $fill} fill=\"{$fill}\"{/if}")
		fmt.Fprintf(out, "{if $stroke} stroke=\"{$stroke}\"{/if}")
		fmt.Fprintf(out, "{if $strokeWidth} stroke-width=\"{$strokeWidth}\"{/if}")
	}

	// Self-closing tag or opening tag with children
	if len(node.Children) == 0 && node.Value == "" {
		fmt.Fprintf(out, "></%s>\n", node.Name)
	} else {
		fmt.Fprintf(out, ">")

		// Render value if present
		if node.Value != "" {
			fmt.Fprintf(out, "%s", node.Value)
		}

		// Render children recursively
		if len(node.Children) > 0 {
			fmt.Fprintf(out, "\n")
			for _, child := range node.Children {
				// Only the immediate children of the root svg get special treatment
				childIsFirstG := isRoot && node.Name == "svg" && child.Name == "g"
				renderNode(out, child, indent+"  ", childIsFirstG)
			}
			fmt.Fprintf(out, "%s", indent)
		}

		// Closing tag
		fmt.Fprintf(out, "</%s>\n", node.Name)
	}
}

func parseFlags(args []string) (cfg Config, err error) {
	fs := flag.NewFlagSet(toolName, flag.ExitOnError)
	fs.StringVar(&cfg.OutputFile, "output_file", "", "the output .soy file to write")
	fs.StringVar(&cfg.OcticonsJSONFile, "octicons_json_file", "", "the octicons data.json file to read")
	fs.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "usage: %s @PARAMS_FILE\n", toolName)
		fs.PrintDefaults()
	}

	if err = fs.Parse(args); err != nil {
		return
	}

	return
}

// toCamelCase converts kebab-case to camelCase
// e.g., "zoom-out" -> "zoomOut", "package" -> "package"
func toCamelCase(s string) string {
	parts := strings.Split(s, "-")
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

// getSortedSizes returns the available sizes for an icon, sorted numerically
func getSortedSizes(heights map[string]IconHeight) []string {
	sizes := make([]string, 0, len(heights))
	for size := range heights {
		sizes = append(sizes, size)
	}

	// Sort sizes numerically
	sort.Slice(sizes, func(i, j int) bool {
		// Parse as integers for proper numeric sorting
		var a, b int
		fmt.Sscanf(sizes[i], "%d", &a)
		fmt.Sscanf(sizes[j], "%d", &b)
		return a < b
	})

	return sizes
}
